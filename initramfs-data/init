#!/bin/busybox sh

root_mount="/mnt/root"

# installs symlinks for all busybox provided binaries
/bin/busybox --install -s

# provides a busybox shell if this script fails
rescue_shell() {
	echo "Error: $@"
	echo "Dropping to recovery shell."
	exec /bin/sh
}

# tries to use mdev to populate /dev, falling back on devtmpfs
# because mdev is suitable for loading firmware (devtmpfs isn't)
mount_dev() {
	if [ -x /sbin/mdev ]; then
		echo /sbin/mdev > /proc/sys/kernel/hotplug
		mount -t tmpfs none /dev
		# if this works we're done, otherwise fall through
		/sbin/mdev -s && return 0
	fi
	mount -t devtmpfs none /dev
}

# mounts things this file needs
set_mounts() {
	# proc and sys
	mount -t sysfs none /sys && mount -t proc none /proc && mount_dev
}
# moves the mount or unmounts it if it failed to move it
move_mount() {
	mount --move "$@" "$root_mount/$@" || umount "$@"
}
# unmounts everything this file mounted
relocate_mounts() {
	move_mount /sys
	move_mount /proc
	move_mount /dev
}

# processes the command line to handle mounting based upon UUID
uuidlabel_root() {
	for cmd in $(cat /proc/cmdline); do
		case "$cmd" in
			root=*)
				dev="${cmd#root=}"
				type="${dev%%=*}"
				# if it's a label or uuid, look it up and update dev
				if [ "$type" = "LABEL" ] || [ "$type" = "UUID" ] ; then
					dev="$(findfs "$dev")"
				fi
				# mount it
				mount -o ro "$dev" "$root_mount"
				# return code indicates mounting success
				return $?
			;;
		esac
	done
}



# mount what we need
set_mounts || rescue_shell "Couldn't mount one or more of {proc,sys,dev}"

# try to mount the root filesystem
uuidlabel_root || rescue_shell "Couldn't mount root filesystem; UUID may be invalid or you may be missing your hard-disk controller's drivers."

# unmount things we no longer need; moves dev over to root, too
relocate_mounts

# boot the real thing.
exec switch_root "$root_mount" /sbin/init

# vi:set ft=sh:
